// puppeteer-extra is a drop-in replacement for puppeteer,
// it augments the installed puppeteer with plugin functionality.
// Any number of plugins can be added through `puppeteer.use()`
var puppeteer = require('puppeteer-extra')

// Add stealth plugin and use defaults (all tricks to hide puppeteer usage)
var StealthPlugin = require('puppeteer-extra-plugin-stealth')
puppeteer.use(StealthPlugin())

// Add adblocker plugin to block all ads and trackers (saves bandwidth)
var AdblockerPlugin = require('puppeteer-extra-plugin-adblocker')
puppeteer.use(AdblockerPlugin({ blockTrackers: true }))

// Dom Parser
const { DOMParser } = require('xmldom')

/**
* Function get host
* @htmldom    {xmldom} name    HTML DOM 
* @return     {String}         Return product Title
*/
let getSiteHostname = function (url ) {
    result = findAttribute(htmldom, 'a', 'href',1);
    return url.replace(" ","%20");
}

/**
* Function replace space with %20
* @htmldom    {xmldom} name    HTML DOM 
* @return     {String}         Return product Title
*/
let replaceSpace = function (url ) {
    return url.replace(" ","%20");
}

/**
* Function find first attribute from html DOM based on tagname and attribute 
* @htmldom    {xmldom} name    HTML DOM 
* @return     {String}         Return product Title
*/
let findAttribute = function (htmldom, tagName, propertyMatch, attr, matchpos) {

    let result = "";

    let tag = Array.from(htmldom.getElementsByTagName(tagName));
    tag.every( element => {
        
        let indx = 1;
        let property = propertyMatch.split('=')[0]
        let value = propertyMatch.split('=')[1]
        let result = ''
        let attributeValue = ''

        result = element.getAttribute(property);
        attributeValue = element.getAttribute(attr);
        
        console.log(result , attributeValue);

        if (result == value && attributeValue != "" && matchpos == indx) {
            return false;
        }

        indx++;

        return true;
    });

    return result;
}

/**
* Function return the product detailed page
* @htmldom    {xmldom} name    HTML DOM 
* @return     {String}         Return product Title
*/
let getProductDetailPageURL = function (htmldom) {
    
    result = findAttribute(htmldom, 'meta', 'property=og:url','content',1);
    result = replaceSpace(result);
    console.log("href: " + result );
    return result;

}

/**
* Function return the product Title
* @htmldom    {xmldom} name    HTML DOM 
* @return     {String}         Return product Title
*/
let getProductTitle = function (htmldom)  {

    result = findAttribute(htmldom, 'a', 'title', 1)
    console.log("title: " + result );
    return result;

};

/**
* Function return the product Title
* @htmldom    {xmldom} name    HTML DOM 
* @return     {String}         Return product Title
*/
let getProductImage = function (htmldom) {

    let tagImg = htmldom.getElementsByTagName('img');
    return tagImg[1].attribute[0];

};

function run (pagesToScrape) {
    promise = new Promise(async (resolve, reject) => {
        try {
            if (!pagesToScrape) {
                pagesToScrape = 1;
            }

            const browserFetcher = puppeteer.createBrowserFetcher();
            let revisionInfo = await browserFetcher.download('938248');

            var doAction = function () {
                let test=1;
                // your function code here
            }
            
            

            const browser = await puppeteer.launch( {  headless: false,
            args: ["--no-sandbox"] } );

            const page = await browser.newPage();
            // Ackknowledge popup request location access
            
            await page.on('body', async dialog => {
                console.log('here');
                await dialog.accept();ÃŸ
            });

            await page.setRequestInterception(true);

            // page.on('request', (request) => {
            //     if (request.resourceType() === 'document') {
            //         request.continue();
            //     } else {
            //         request.abort();
            //     }
            // });

            await page.goto("https://www.homehardware.ca/en/thermostats/c/7449");

            let currentPage = 1;
            let urls = [];

            while (currentPage <= pagesToScrape) {

                let selector = 'div.mz-productlisting.datalayer-parent-element.ign-data-product-impression.mz-productlist-tiled';
                await page.waitForSelector(selector);

                selector = 'head' 
                let arrayOfItems = await page.evaluate((selector) => {
                    
                    let results = [];

                    
                    const myNodeList = document.querySelectorAll(selector);

                    const myArray = []; // empty Array
                    for (let i = 0; i < myNodeList.length; i++) {
                        const self = myNodeList[i];
                        myArray.push(self.innerHTML);
                    }

                    return myArray;

                }, selector);

                arrayOfItems.forEach(html => {

                    let parsedHtml = new DOMParser().parseFromString(html, 'text/html');
                    let productDetailPageURL = getProductDetailPageURL(parsedHtml);

                    let productTitle = getProductTitle(parsedHtml);
                    let productDesc = getProductDesc(parsedHtml);
                    let productStar = getProductStar(parsedHtml);
                    let productRegularPrice = getProductPrice(parsedHtml);
                    let productCurrentPrice = getProductPrice(parsedHtml);
                    let productDiscounted = getProductPrice(parsedHtml);
                    let productUnitCount = getProductPrice(parsedHtml);
                    let productUnit = getProductPrice(parsedHtml);
                    let productImgURL = getProductImgURL(parsedHtml);
                    let productImg = getProductImg(parsedHtml);
                    let productFetchDate = getProductFetchDate(parsedHtml);
                    
                });

                
                currentPage++;

            }

            browser.close();

            return resolve(urls);

        } catch (e) {

            return reject(e);
        }
    })
    
    return promise;
}
run(1).then(console.log).catch(console.error);
